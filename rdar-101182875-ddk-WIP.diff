diff --git a/Source/WebCore/loader/FTPDirectoryParser.cpp b/Source/WebCore/loader/FTPDirectoryParser.cpp
index 81a9cdaf8705..cc0c83ea05f5 100644
--- a/Source/WebCore/loader/FTPDirectoryParser.cpp
+++ b/Source/WebCore/loader/FTPDirectoryParser.cpp
@@ -116,8 +116,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
       }
     }    
 
-    if (!numtoks)
+    if (!numtoks) {
+      result.clear();
       return ParsingFailed(state);
+    }
 
     linelen_sans_wsp = &(tokens[numtoks-1][toklen[numtoks-1]]) - tokens[0];
     if (numtoks == WTF_ARRAY_LENGTH(tokens))
@@ -270,6 +272,7 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
           if (pos == 0)
           {  
             state.listStyle = 'V';
+            result.clear();
             return FTPJunkEntry; /* its junk */
           }
         }
@@ -393,6 +396,7 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
               pos = (sizeof(state.carryBuffer)-1); /* shouldn't happen */
             memcpy( state.carryBuffer, p, pos );
             state.carryBufferLength = pos;
+            result.clear();
             return FTPJunkEntry; /* tell caller to treat as junk */
           }
           else if (isASCIIDigit(*tokens[1])) /* not no-privs message */
@@ -540,6 +544,7 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
 
         } /* if (isASCIIDigit(*tokens[1])) */
 
+        result.clear();
         return FTPJunkEntry; /* junk */
 
       } /* if (lstyle == 'V') */
@@ -711,8 +716,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
 
         /* oldstyle LISTING: 
          * files/dirs not on the 'A' minidisk are not RETRievable/CHDIRable 
-        if (toklen[tokmarker+4] != 10 && *tokens[tokmarker-1] != 'A')
+        if (toklen[tokmarker+4] != 10 && *tokens[tokmarker-1] != 'A') {
+          result.clear();
           return FTPJunkEntry;
+        }
         */
         
         /* VM/CMS LISTings have no usable filesize field. 
@@ -849,7 +856,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
         if (result.type == FTPDirectoryEntry && result.filename[0] == '.' &&
             (result.filenameLength == 1 || (result.filenameLength == 2 &&
                                       result.filename[1] == '.')))
+        {
+          result.clear();
           return FTPJunkEntry;
+        }
         */
 
         return result.type;  
@@ -950,7 +960,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
         if (result.type == FTPDirectoryEntry && result.filename[0] == '.' &&
             (result.filenameLength == 1 || (result.filenameLength == 2 &&
                                       result.filename[1] == '.')))
+        {
+          result.clear();
           return FTPJunkEntry;
+        }
         */
 
         return result.type;
@@ -1230,7 +1243,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
         if (result.type == FTPDirectoryEntry && result.filename[0] == '.' &&
             (result.filenameLength == 1 || (result.filenameLength == 2 &&
                                       result.filename[1] == '.')))
+        {
+          result.clear();
           return FTPJunkEntry;
+        }
         */
 
         return result.type;  
@@ -1374,7 +1390,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
         if (result.type == FTPDirectoryEntry && result.filename[0] == '.' &&
             (result.filenameLength == 1 || (result.filenameLength == 2 &&
                                       result.filename[1] == '.')))
+        {
+          result.clear();
           return FTPJunkEntry;
+        }
         */
 
         return result.type;
@@ -1447,6 +1466,7 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
         if (pos == (linelen-1))
         {
           state.listStyle = 'D';
+          result.clear();
           return FTPJunkEntry;
         }
       }
@@ -1521,6 +1541,7 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
           pos = sizeof(state.carryBuffer)-1;
         memcpy( state.carryBuffer, line, pos );
         state.carryBufferLength = pos;
+        result.clear();
         return FTPJunkEntry;
       }
 
@@ -1649,7 +1670,10 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
         if (result.type == FTPDirectoryEntry && result.filename[0] == '.' &&
             (result.filenameLength == 1 || (result.filenameLength == 2 &&
                                       result.filename[1] == '.')))
+        {
+          result.clear();
           return FTPJunkEntry;
+        }
         */
 
         return result.type;
@@ -1662,6 +1686,7 @@ FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& res
 
   } /* if (linelen > 0) */
 
+  result.clear();
   return ParsingFailed(state);
 }
 
diff --git a/Tools/TestWebKitAPI/Tests/WebCore/FTPDirectoryParserTests.cpp b/Tools/TestWebKitAPI/Tests/WebCore/FTPDirectoryParserTests.cpp
new file mode 100644
index 000000000000..98e89a945fec
--- /dev/null
+++ b/Tools/TestWebKitAPI/Tests/WebCore/FTPDirectoryParserTests.cpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2022 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#include <WebCore/FTPDirectoryParser.h>
+
+namespace TestWebKitAPI {
+
+// FIXME: FTPEntryType parseOneFTPLine(const char* line, ListState& state, ListResult& result)
+
+static bool testListResultIsClear(const ListResult& result)
+{
+    EXPECT_EQ(false, result.valid);
+    EXPECT_EQ(FTPJunkEntry, result.type);
+    EXPECT_EQ(nullptr, result.filename);
+    EXPECT_EQ(0, result.filenameLength);
+    EXPECT_EQ(nullptr, result.linkname);
+    EXPECT_EQ(0, result.linknameLength);
+    EXPECT_EQ(String(), result.fileSize);
+    EXPECT_EQ(false, result.caseSensitive);
+    EXPECT_EQ(FTPTime { }, result.modifiedTime);
+}
+
+TEST(FTPDirectoryParser, EmptyLine)
+{
+    ListState state;
+    ListResult result;
+    FTPEntryType type = parseOneFTPLine(nullptr, state, result);
+
+    EXPECT_EQ(FTPJunkEntry, type);
+    testListResultIsClear(result);
+}
+
+} // namespace TestWebKitAPI
